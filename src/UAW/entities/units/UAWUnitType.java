package UAW.entities.units;

import UAW.audiovisual.Outliner;
import UAW.entities.units.entity.*;
import UAW.type.Rotor;
import UAW.type.Rotor.RotorMount;
import arc.Core;
import arc.graphics.Color;
import arc.graphics.g2d.*;
import arc.math.*;
import arc.struct.Seq;
import arc.util.Time;
import mindustry.Vars;
import mindustry.content.Fx;
import mindustry.gen.Unit;
import mindustry.graphics.*;
import mindustry.type.UnitType;
import mindustry.world.blocks.environment.Floor;

import static mindustry.Vars.world;

@Deprecated
public class UAWUnitType extends UnitType {
	public final Seq<Rotor> rotors = new Seq<>();
//	public final Seq<TankWeapon> tWeapons = new Seq<>();

	// Helicopters
	public float spinningFallSpeed = 0;
	public float rotorDeathSlowdown = 0.01f;
	public float fallSmokeX = 0f, fallSmokeY = -5f, fallSmokeChance = 0.1f;

	// Tanks
	public TextureRegion hullRegion, hullOutlineRegion, hullCellRegion, turretCellRegion;
	public float turretX = 0f, turretY = 0f;
	public float groundTrailSize = 1;
	public float groundTrailInterval = 0.5f;
	public float groundTrailSpacing = 0f, groundTrailY = 0f;
	public float terrainSpeedMultiplier = 1f;
	public boolean drawHullCell = true;

	// Jets
	public float engineSizeShrink = 0.1f;
	public float jetTrailX = 0, jetTrailY = 0;
	public int jetTrailLength = 0;
	public float jetTrailScl = 0f;
	public boolean jetMovement = true;

	protected float timer;

	public UAWUnitType(String name) {
		super(name);
	}

	@Override
	public void draw(Unit unit) {
		float z = unit.elevation > 0.5f ? (lowAltitude ? Layer.flyingUnitLow : Layer.flyingUnit) : groundLayer + Mathf.clamp(hitSize / 4000f, 0, 0.01f);
		super.draw(unit);
		if (unit instanceof TankUnitEntity tank) {
			Draw.z(z - 0.05f);
			drawTankHullOutline(tank);
			drawTankHull(tank);
		}
		Draw.z(z);
		drawRotor(unit);
	}

	@Override
	public void drawSoftShadow(Unit unit, float alpha) {
		float z = unit.elevation > 0.5f ? (lowAltitude ? Layer.flyingUnitLow : Layer.flyingUnit) : groundLayer + Mathf.clamp(hitSize / 4000f, 0, 0.01f);
		if (unit instanceof CopterUnitEntity) {
			Draw.z(z - 3f);
			super.drawSoftShadow(unit, alpha);
		} else if (unit instanceof TankUnitEntity) {
			float rad = 1.6f;
			float size = Math.max(hullRegion.width * 0.7f, hullRegion.height * 0.7f) * Draw.scl;
			Draw.z(z - 3f);
			Draw.color(0, 0, 0, 0.4f * alpha);
			Draw.rect(softShadowRegion, unit, size * rad * Draw.xscl, size * rad * Draw.yscl, unit.rotation - 90);
			Draw.color();
		} else {
			super.drawSoftShadow(unit, alpha);
		}
	}

	// Copter Rotors
	public void drawRotor(Unit unit) {
		float z = unit.elevation > 0.5f ? (lowAltitude ? Layer.flyingUnitLow : Layer.flyingUnit) : groundLayer + Mathf.clamp(hitSize / 4000f, 0, 0.01f);
		applyColor(unit);
		if (unit instanceof CopterUnitEntity copter) {
			for (RotorMount mount : copter.rotors) {
				Rotor rotor = mount.rotor;
				float rx = unit.x + Angles.trnsx(unit.rotation - 90, rotor.x, rotor.y);
				float ry = unit.y + Angles.trnsy(unit.rotation - 90, rotor.x, rotor.y);
				float rotorScl = Draw.scl * rotor.rotorSizeScl;
				float rotorTopScl = Draw.scl * rotor.rotorTopSizeScl;

				for (int i = 0; i < rotor.bladeCount; i++) {
					float angle = (i * 360f / rotor.bladeCount + mount.rotorRotation) % 360;
					float blurAngle = (i * 360f / rotor.bladeCount + (mount.rotorRotation * rotor.rotorBlurSpeedMultiplier)) % 360;

					// region Normal Rotor
					Draw.z(z + rotor.rotorLayer);
					Draw.alpha(rotor.bladeBlurRegion.found() ? 1 - (copter.rotorSpeedScl / 0.8f) : 1);
					Draw.rect(
						rotor.bladeOutlineRegion, rx, ry,
						rotor.bladeOutlineRegion.width * rotorScl,
						rotor.bladeOutlineRegion.height * rotorScl,
						angle
					);
					Draw.mixcol(Color.white, unit.hitTime);
					Draw.rect(rotor.bladeRegion, rx, ry,
						rotor.bladeRegion.width * rotorScl,
						rotor.bladeRegion.height * rotorScl,
						angle
					);
					// endregion Normal Rotor

					// Double Rotor
					if (rotor.doubleRotor) {
						Draw.rect(
							rotor.bladeOutlineRegion, rx, ry,
							rotor.bladeOutlineRegion.width * rotorScl * -Mathf.sign(false),
							rotor.bladeOutlineRegion.height * rotorScl,
							-angle
						);
						Draw.mixcol(Color.white, unit.hitTime);
						Draw.rect(rotor.bladeRegion, rx, ry,
							rotor.bladeRegion.width * rotorScl * -Mathf.sign(false),
							rotor.bladeRegion.height * rotorScl,
							-angle
						);
					}
					Draw.reset();

					// Blur Rotor
					if (rotor.bladeBlurRegion.found()) {
						Draw.z(z + rotor.rotorLayer);
						Draw.alpha(copter.rotorSpeedScl * rotor.rotorBlurAlphaMultiplier * (copter.dead() ? copter.rotorSpeedScl * 0.5f : 1));
						Draw.rect(
							rotor.bladeBlurRegion, rx, ry,
							rotor.bladeBlurRegion.width * rotorScl,
							rotor.bladeBlurRegion.height * rotorScl,
							-blurAngle
						);

						// Double Rotor Blur
						if (rotor.doubleRotor) {
							Draw.rect(
								rotor.bladeBlurRegion, rx, ry,
								rotor.bladeBlurRegion.width * rotorScl * -Mathf.sign(false),
								rotor.bladeBlurRegion.height * rotorScl,
								blurAngle
							);
						}
						Draw.reset();
					}

					Draw.reset();

					// Rotor Top
					if (rotor.drawRotorTop) {
						Draw.z(z + rotor.rotorLayer + 0.001f);
						Draw.rect(
							rotor.topRegionOutline, rx, ry,
							rotor.topRegionOutline.width * rotorTopScl,
							rotor.topRegionOutline.height * rotorTopScl,
							unit.rotation - 90);
						Draw.mixcol(Color.white, unit.hitTime);
						Draw.rect(
							rotor.topRegion, rx, ry,
							rotor.topRegion.width * rotorTopScl,
							rotor.topRegion.height * rotorTopScl,
							unit.rotation - 90
						);
					}
					Draw.reset();
				}
			}
		}
	}

	// Tank Hull Outline
	public void drawTankHullOutline(TankUnitEntity tank) {
		Draw.reset();
		applyColor(tank);
		applyOutlineColor(tank);
		Draw.rect(hullOutlineRegion, tank, tank.hullRotation - 90);
	}

	// Tank Hull
	public void drawTankHull(TankUnitEntity tank) {
		Draw.mixcol(Color.white, tank.hitTime);
		applyColor(tank);
		Draw.rect(hullRegion, tank, tank.hullRotation - 90);
		if (drawHullCell) {
			Draw.color(cellColor(tank));
			Draw.rect(hullCellRegion, tank, tank.hullRotation - 90);
		}
		Draw.mixcol();
		Draw.reset();
	}

	// Tank Turret, new method is unnecessary
	@Override
	public void drawBody(Unit unit) {
		if (unit instanceof TankUnitEntity tank) {
			float x = tank.x + Angles.trnsx(tank.hullRotation, turretX, turretY);
			float y = tank.y + Angles.trnsy(tank.hullRotation, turretX, turretY);
			applyColor(unit);
			Draw.rect(region, x, y, unit.rotation - 90);
			Draw.reset();
		} else super.drawBody(unit);
	}

	// Tank Trail
	public void drawTankTrail(Unit unit) {
		Floor floor = Vars.world.floorWorld(unit.x, unit.y);
		Color floorColor = floor.mapColor;
		if (unit instanceof TankUnitEntity tank) {
			if (((timer += Time.delta) >= groundTrailInterval)
				&& !floor.isLiquid && unit.moving() && groundTrailSize > 0) {
				for (int i : Mathf.zeroOne) {
					int side = Mathf.signs[i];
					float tankTrailOffset = groundTrailSpacing * side;
					Fx.unitLandSmall.at(
						unit.x + Angles.trnsx(tank.hullRotation - 90, tankTrailOffset, groundTrailY),
						unit.y + Angles.trnsy(tank.hullRotation - 90, tankTrailOffset, groundTrailY),
						(hitSize / 24) * groundTrailSize,
						floorColor
					);
				}
				timer = 0f;
			}
		}
	}


	@Override
	public void drawShadow(Unit unit) {
		if (unit instanceof TankUnitEntity tank) {
			float e = Math.max(unit.elevation, shadowElevation) * (1f - unit.drownTime);
			float x = unit.x + shadowTX * e, y = unit.y + shadowTY * e;
			Floor floor = world.floorWorld(x, y);
			float dest = floor.canShadow ? 1f : 0f;
			unit.shadowAlpha = unit.shadowAlpha < 0 ? dest : Mathf.approachDelta(unit.shadowAlpha, dest, 0.11f);
			Draw.color(Pal.shadow, Pal.shadow.a * unit.shadowAlpha);
			Draw.rect(hullRegion, unit.x + shadowTX * e, unit.y + shadowTY * e, tank.hullRotation - 90);
			Draw.color();
		} else super.drawShadow(unit);
	}

	@Override
	public void init() {
		Unit example = constructor.get();
		super.init();
		if (example instanceof TankUnitEntity) {
			groundLayer = Layer.groundUnit - 2;
			if (shadowElevation < 0f) {
				shadowElevation = 0.12f;
			}
		}

//		// Mirrors heli rotors
//		Seq<Rotor> rotorMapped = new Seq<>();
//		for (Rotor rotor : rotors) {
//			rotorMapped.add(rotor);
//			if (rotor.mirror) {
//				Rotor copy = rotor.copy();
//
//				copy.x *= -1;
//				copy.rotorSpeed *= -1;
//				copy.rotorBlurSpeedMultiplier *= -1;
//
//				rotorMapped.add(copy);
//			}
//		}

	}

	@Override
	public void update(Unit unit) {
		super.update(unit);
		drawTankTrail(unit);
	}

	@Override
	public void createIcons(MultiPacker packer) {
		super.createIcons(packer);
		// Helicopter Rotors
		for (Rotor rotor : rotors) {
			Outliner.outlineRegion(packer, rotor.bladeRegion, outlineColor, rotor.name + "-outline", outlineRadius);
			Outliner.outlineRegion(packer, rotor.topRegion, outlineColor, rotor.name + "-top-outline", outlineRadius);
		}
		// Tanks
//		Outliner.outlineRegion(packer, hullRegion, outlineColor, name + "-hull-outline", outlineRadius);
//		for (TankWeapon tankWeapon : tWeapons) {
//			Outliner.outlineRegion(packer, tankWeapon.gunOutline, outlineColor, tankWeapon.name + "-outline", outlineRadius);
//		}
	}

	@Override
	public void load() {
		super.load();
		rotors.each(Rotor::load);
		hullRegion = Core.atlas.find(name + "-hull");
		hullOutlineRegion = Core.atlas.find(name + "-hull-outline");
		turretCellRegion = Core.atlas.find(name + "-turret-cell");
		hullCellRegion = Core.atlas.find(name + "-hull-cell");
	}
}




